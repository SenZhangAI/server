#
# Testing SORT-NEST with non-flattened Subqueries
#

#
# Dependent subquery attached to table t3 outside the sort-nest(t1,t2)
#
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, b int);
insert into t1 select a,a from t0 where a <5;
create table t2 as select * from t1 where a < 5;
create table t3(a int, b int, c int);
insert into t3 select A.a + 10*B.a, A.a + 10*B.a, A.a + 10*B.a from t0 A, t0 B;
create table t4(a int, b int, c int, key(b));
insert into t4 select A.a + 10*B.a, A.a + 10*B.a, A.a + 10*B.a from t0 A, t0 B;
# ref access inside the dependent subquery should be with sort-nest.b instead of t1.b
# subquery is attached to table t3 which is outside the sort-nest
EXPLAIN SELECT * FROM t1,t2,t3
WHERE t1.b=t2.b and
EXISTS (select 1 from t4 where t4.b=t1.b and t4.b < 4 group by t4.c having t3.b=max(t4.a))
ORDER BY t2.a desc,t1.a desc
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	5	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	PRIMARY	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	100	Using where
2	DEPENDENT SUBQUERY	t4	ref	b	b	5	sort-nest.b	1	Using index condition; Using where; Using temporary
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE t1.b=t2.b and
EXISTS (select 1 from t4 where t4.b=t1.b and t4.b < 4 group by t4.c having t3.b=max(t4.a))
ORDER BY t2.a desc,t1.a desc
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 5,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 5,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL",
      "attached_condition": "t2.b = t1.b"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.a desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100,
      "attached_condition": "<in_optimizer>(1,exists(subquery#2))"
    },
    "subqueries": [
      {
        "expression_cache": {
          "state": "uninitialized",
          "query_block": {
            "select_id": 2,
            "outer_ref_condition": "`sort-nest`.b is not null",
            "having_condition": "t3.b = max(t4.a)",
            "temporary_table": {
              "table": {
                "table_name": "t4",
                "access_type": "ref",
                "possible_keys": ["b"],
                "key": "b",
                "key_length": "5",
                "used_key_parts": ["b"],
                "ref": ["sort-nest.b"],
                "rows": 1,
                "filtered": 100,
                "index_condition": "t4.b < 4",
                "attached_condition": "t4.b <=> `sort-nest`.b"
              }
            }
          }
        }
      }
    ]
  }
}
SELECT * FROM t1,t2,t3
WHERE t1.b=t2.b and
EXISTS (select 1 from t4 where t4.b=t1.b and t4.b < 4 group by t4.c having t3.b=max(t4.a))
ORDER BY t2.a desc,t1.a desc
LIMIT 5;
a	b	a	b	a	b	c
3	3	3	3	3	3	3
2	2	2	2	2	2	2
1	1	1	1	1	1	1
0	0	0	0	0	0	0
# same as above but exists to in transformation not allowed
# subquery is attached to table t3 which is outside the sort-nest
set optimizer_switch='exists_to_in=off';
EXPLAIN SELECT * FROM t1,t2,t3
WHERE t1.b=t2.b and
EXISTS (select 1 from t4 where t4.b=t1.b and t4.b < 4 group by t4.c having t3.b=max(t4.a))
ORDER BY t2.a desc,t1.a desc
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	5	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	PRIMARY	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	100	Using where
2	DEPENDENT SUBQUERY	t4	ref	b	b	5	sort-nest.b	1	Using index condition; Using where; Using temporary
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE t1.b=t2.b and
EXISTS (select 1 from t4 where t4.b=t1.b and t4.b < 4 group by t4.c having t3.b=max(t4.a))
ORDER BY t2.a desc,t1.a desc
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 5,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 5,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL",
      "attached_condition": "t2.b = t1.b"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.a desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100,
      "attached_condition": "exists(subquery#2)"
    },
    "subqueries": [
      {
        "expression_cache": {
          "state": "uninitialized",
          "query_block": {
            "select_id": 2,
            "outer_ref_condition": "`sort-nest`.b is not null",
            "having_condition": "t3.b = max(t4.a)",
            "temporary_table": {
              "table": {
                "table_name": "t4",
                "access_type": "ref",
                "possible_keys": ["b"],
                "key": "b",
                "key_length": "5",
                "used_key_parts": ["b"],
                "ref": ["sort-nest.b"],
                "rows": 1,
                "filtered": 100,
                "index_condition": "t4.b < 4",
                "attached_condition": "t4.b <=> `sort-nest`.b"
              }
            }
          }
        }
      }
    ]
  }
}
SELECT * FROM t1,t2,t3
WHERE t1.b=t2.b and
EXISTS (select 1 from t4 where t4.b=t1.b and t4.b < 4 group by t4.c having t3.b=max(t4.a))
ORDER BY t2.a desc,t1.a desc
LIMIT 5;
a	b	a	b	a	b	c
3	3	3	3	3	3	3
2	2	2	2	2	2	2
1	1	1	1	1	1	1
0	0	0	0	0	0	0
set optimizer_switch=default;
drop table t0,t1,t2,t3,t4;
